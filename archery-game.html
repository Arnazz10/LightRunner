<!DOCTYPE html>
<html>
<head>
  <title>Archery Game Improved</title>
  <style>
    body { margin: 0; }
    canvas {
      display: block;
      margin: auto;
      background: linear-gradient(to top, #87ceeb, #e0f7fa);
      border: 2px solid #444;
    }
  </style>
</head>
<body>
<canvas id="game" width="900" height="500"></canvas>

<script>
// Setup
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// Bow position
const origin = { x: 120, y: 350 };
let isDragging = false;
let dragPos = { x: origin.x, y: origin.y };

// Arrow state
let arrow = {
  x: origin.x, y: origin.y,
  vx: 0, vy: 0,
  flying: false
};

function resetArrow() {
  arrow = { x: origin.x, y: origin.y, vx: 0, vy: 0, flying: false };
}

// Event Listeners
canvas.addEventListener("mousedown", (e) => {
  if (!arrow.flying) {
    isDragging = true;
    const rect = canvas.getBoundingClientRect();
    dragPos = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }
});

canvas.addEventListener("mouseup", (e) => {
  if (isDragging) {
    isDragging = false;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Calculate power
    let dx = origin.x - mouseX;
    let dy = origin.y - mouseY;
    const power = Math.min(Math.hypot(dx, dy), 100); // Limit power
    const angle = Math.atan2(dy, dx);

    arrow.vx = (power * Math.cos(angle)) * 0.5;
    arrow.vy = (power * Math.sin(angle)) * 0.5;
    arrow.flying = true;
  }
});

// Drawing Functions
function drawArrow(x, y, angle) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.fillStyle = "#6B4226"; // Arrow brown
  ctx.fillRect(-25, -3, 50, 6);
  ctx.restore();
}

function drawBow() {
  ctx.beginPath();
  ctx.arc(origin.x, origin.y, 40, Math.PI / 2, Math.PI * 3 / 2);
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 4;
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(origin.x, origin.y - 40);
  ctx.lineTo(origin.x, origin.y + 40);
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawTarget() {
  const cx = 750, cy = 350;
  [30, 20, 10].forEach((r, i) => {
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fillStyle = ["red", "white", "blue"][i];
    ctx.fill();
  });
}

// Main Update Loop
function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawTarget();
  drawBow();

  if (isDragging) {
    // Draw aim line
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(dragPos.x, dragPos.y);
    ctx.strokeStyle = "rgba(0,0,0,0.5)";
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.setLineDash([]);

    const dx = origin.x - dragPos.x;
    const dy = origin.y - dragPos.y;
    const angle = Math.atan2(dy, dx);
    drawArrow(origin.x, origin.y, angle);
  } else if (arrow.flying) {
    // Update arrow
    arrow.x += arrow.vx;
    arrow.y += arrow.vy;
    arrow.vy += 0.4; // gravity
    const angle = Math.atan2(arrow.vy, arrow.vx);
    drawArrow(arrow.x, arrow.y, angle);

    // Off screen reset
    if (arrow.x > canvas.width || arrow.y > canvas.height) {
      resetArrow();
    }
  } else {
    drawArrow(origin.x, origin.y, 0);
  }

  requestAnimationFrame(update);
}
update();
</script>
</body>
</html>
